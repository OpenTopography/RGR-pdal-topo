import os
from time import sleep

import numpy as np
from matplotlib import pyplot as plt
from matplotlib.widgets import RectangleSelector
import scipy.ndimage as ndi

from scipy import optimize

#Import local related components
try:
    import demAnalysisComponents.randomGrids as randGrid
    from demAnalysisComponents.baseGrid import baseGrid
    from demAnalysisComponents.FileSuffixDictionary import FILESUFFIXDICT
except:
    # from randomGrids import randGrid
    from baseGrid import baseGrid
    from FileSuffixDictionary import FILESUFFIXDICT

class demGrid(baseGrid):

    def calcPlaneCoefficientsToGrid(self, X : np.ndarray = None, Y : np.ndarray = None):
        '''
        Fits a flat plane (linear, least squares) to the values in this grid and returns the coefficients of that grid.

        If X and Y are not specified, they are generated to be all of the X,Y coordinates in the grid.
        If X and Y are specified (and are NOT the same shape as the grid), uses the subset of grid values that
        correspond to the closest values at these X,Y positions. If X and Y ARE the same shape as the grid, we assume
        that they correspond to the X,Y coordinates of every point in the grid (e.g., generated by numpy.meshgrid())

        :param X: numpy array of X coordinates of grid cells to fit the elevations for. If None is specified, values
        will be derived for all pixels
        :param Y: numpy array of Y coordinates of grid cells to fit the elevations for. If None is specified, values
        will be derived for all pixels
        :return: [Sx,Sy,Int] - array of fitted coefficients to a plane for this grid
        '''

        if (X is None) or (Y is None):
            X, Y = self.getGridCoordinatesMeshgrid()

        #Check the shapes of the X,Y coordinates, if they are the same size as this grid, assume that we are
        #using all grid values
        if (X.shape == self.shape) & (Y.shape == self.shape):
            # Coordinates for data
            A = np.column_stack((X.flatten(), Y.flatten(), np.ones(X.size)))

            # Fit a plane to the grid
            planeCoeffs = np.linalg.lstsq(A, self.grid.flatten(),rcond = None)[0]
        else:
            #If this is a subset of grid values, first get the z values corresponding to those x,y pairs
            z = np.zeros(len(X.flatten()))
            x = X.flatten()
            y = Y.flatten()
            for i in range(len(x)):
                z[i] = self.getGridValueAtPoint([x[i], y[i]])

            # Coordinates for data
            A = np.column_stack((x, y, np.ones_like(x)))

            # Fit a plane to the grid
            planeCoeffs = np.linalg.lstsq(A, z, rcond=None)[0]

        return planeCoeffs

    def removePlaneFromGrid(self, planeCoeffs = None, modifyGridInPlace = False, X: np.ndarray = None,
                            Y: np.ndarray = None):
        '''
        Remove a plane fit to the grid extent from this grid. If no plane coefficients are specified will preform a
        new fit to this grid. Can optionally modify this grid in place, rather than returning a new grid.

        :param planeCoeffs:  Optional - specify the [Sx,Sy, Int] coordinates of the fitted plane
        :param modifyGridInPlace:  Boolean (deafult: False) - if true, modified the values of this grid
               (NOTE: no way to recover this unless you store the plane coefficients)
        :param X: numpy array of X coordinates of grid cells to fit the elevations for. If None is specified, values
        will be derived for all pixels
        :param Y: numpy array of Y coordinates of grid cells to fit the elevations for. If None is specified, values
        will be derived for all pixels
        :return: this grid, less the plane specified by planeCoeffs fit to this grid.
        '''

        fitGrid = self.calcFittedPlane(planeCoeffs, X= X, Y= Y)

        if modifyGridInPlace:
            self.grid -= fitGrid.grid
        else:
            return self.duplicateGridWithNewArray(self.grid - fitGrid.grid,
                                                  newSuffix=FILESUFFIXDICT['fitted_plane_subtracted'])

    def calcFittedPlane(self, planeCoeffs = None, returnAsArray = False, X: np.ndarray = None,
                            Y: np.ndarray = None):
        '''
        Fits a plane to this grid. If no planeCoeffs are specified then this will be fit to the grid.

        :param planeCoeffs: Optional - specify the components of the fitted plane
        :param returnAsArray: Boolean, if True returns slopes as numpy arrays instead of dem grids
        :param X: numpy array of X coordinates of grid cells to fit the elevations for. If None is specified, values
        will be derived for all pixels
        :param Y: numpy array of Y coordinates of grid cells to fit the elevations for. If None is specified, values
        will be derived for all pixels
        :return: fittedPlane: either a numpy array or demGrid instance with the values of the fitted plane
        '''

        if (X is None) or (Y is None):
            X, Y = self.getGridCoordinatesMeshgrid()

        if planeCoeffs is None:
            planeCoeffs = self.calcPlaneCoefficientsToGrid(X,Y)

        fittedPlane = X * planeCoeffs[0] + Y * planeCoeffs[1] + planeCoeffs[2]

        if not(returnAsArray):
            fittedPlane = self.duplicateGridWithNewArray(fittedPlane, newSuffix=FILESUFFIXDICT['fitted_plane'])

        return fittedPlane

    def _getBCgrid(self, RepeatEdges=True, ReflectBounds = False):
        '''
        Pads the boundaries of the grid so that finite differences are returned at same coordinates of original grid.

        :param RepeatEdges: If true, duplicates the edge values of the existing grid as the boundaries of the new grid
        :param ReflectBounds: If true, copies the grid value from the opposite side of the grid as the new edge
        :return:
        '''

        # Pads the boundaries of a grid
        # Boundary condition pads the boundaries with equivalent values
        # to the data margins, e.g. x[-1,1] = x[1,1]
        # This creates a grid 2 rows and 2 columns larger than the input

        Zbc = np.zeros((self._nrows + 2, self._ncols + 2))  # Create boundary condition array
        Zbc[1:-1, 1:-1] = self.grid  # Insert old grid in center

        if RepeatEdges:
            # Assign boundary conditions - sides
            Zbc[0, 1:-1] = self.grid[0, :]
            Zbc[-1, 1:-1] = self.grid[-1, :]
            Zbc[1:-1, 0] = self.grid[:, 0]
            Zbc[1:-1, -1] = self.grid[:, -1]

            # Assign boundary conditions - corners
            Zbc[0, 0] = self.grid[0, 0]
            Zbc[0, -1] = self.grid[0, -1]
            Zbc[-1, 0] = self.grid[-1, 0]
            Zbc[-1, -1] = self.grid[-1, 0]

        if ReflectBounds:
            # Assign boundary conditions - sides
            Zbc[0, 1:-1] = self.grid[-1, :]
            Zbc[-1, 1:-1] = self.grid[0, :]
            Zbc[1:-1, 0] = self.grid[:, -1]
            Zbc[1:-1, -1] = self.grid[:, 0]

            # Assign boundary conditions - corners
            Zbc[0, 0] = self.grid[-1, -1]
            Zbc[0, -1] = self.grid[-1, 0]
            Zbc[-1, 0] = self.grid[0, -1]
            Zbc[-1, -1] = self.grid[0, 0]

        return Zbc

    def calcSlopes(self, returnAsArray = False):
        '''
        Calculates the 2nd order, centered difference approx for slopes in x and y direction and returns them as numpy
        2d arrays

        Pads the grid so that outputs are the same size as input grid, and 1st order slopes at grid edges is 0
        :param returnAsArray: Boolean, if True returns slopes as numpy arrays instead of dem grids
        :return: Sx, Sy (numpy arrays)

        '''

        # Assign boundary conditions
        Zbc = self._getBCgrid()

        # Compute finite differences
        Sx = (Zbc[1:-1, 2:] - Zbc[1:-1, :-2]) / (2 * self._dx)

        # Note, direction of y derivatives is flipped because high indices are low latitudes (As read in by gdal)
        Sy = (Zbc[:-2, 1:-1] - Zbc[2:, 1:-1] ) / (2 * self._dy)

        if not(returnAsArray):
            Sx = self.duplicateGridWithNewArray(Sx, newSuffix=FILESUFFIXDICT['slope_x'])
            Sy = self.duplicateGridWithNewArray(Sy, newSuffix=FILESUFFIXDICT['slope_y'])

        return Sx, Sy

    def calcSlopeMagnitude(self, returnAsArray = False):
        '''
        Calculates the magnitude of slope at each point in the grid, using a 2nd order, centered difference approximation
        :param returnAsArray: Boolean, if True returns slopes as numpy arrays instead of dem grids
        :return: Smag
        '''

        Sx,Sy = self.calcSlopes(returnAsArray=True)
        Smag = np.sqrt(Sx*Sx + Sy*Sy)
        if not(returnAsArray):
            Smag = self.duplicateGridWithNewArray(Smag, newSuffix= FILESUFFIXDICT['slope_mag'])

        return Smag

    def calcFiniteLaplacian(self, returnAsArray = False):
        '''
        Calculates the 2nd order, centered difference approx for the laplacian/ second derivative of surface

        Pads the grid so that outputs are the same size as input grid, and 1st order slopes at grid edges is 0
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return: d^2 z / dx^2 + d^2 z / dy^2
        '''

        # Assign boundary conditions
        Zbc = self._getBCgrid()

        # Compute finite differences
        Cx = (Zbc[1:-1, 2:] - 2 * Zbc[1:-1, 1:-1] + Zbc[1:-1, :-2]) / self._dx ** 2
        Cy = (Zbc[2:, 1:-1] - 2 * Zbc[1:-1, 1:-1] + Zbc[:-2, 1:-1]) / self._dy ** 2

        C = Cx + Cy

        if not(returnAsArray):
            C = self.duplicateGridWithNewArray(C, newSuffix = FILESUFFIXDICT['laplacian'])

        return C

    def calcContourCurvature(self, returnAsArray = False):
        '''
        Calculates a finte difference aproximation of the contour curvature (e.g., Mitasova and Hofierka, 1993, Math.
        Geol.)
         kt = (fxx*fy^2 - 2*fxyfxfy + fyy*fx^2)/((fx^2 + fy^2)*sqrt((fx^2 + fy^2)+1)
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return: kt
        '''

        # Preallocate
        ContCurv = np.zeros_like(self.grid) * np.nan

        # First derivatives, 2nd order centered difference
        fx = (self.grid[1:-1, 2:] - self.grid[1:-1, :-2]) / (self._dx * 2)
        fy = (self.grid[:-2, 1:-1] - self.grid[2:, 1:-1]) / (self._dy * 2) #Flipped, because of gdal ordering

        # Second derivatives, 2nd order centered differece
        fxx = (self.grid[1:-1, 2:] - 2 * self.grid[1:-1, 1:-1] + self.grid[1:-1, :-2]) / (self._dx ** 2)
        fyy = (self.grid[2:, 1:-1] - 2 * self.grid[1:-1, 1:-1] + self.grid[:-2, 1:-1]) / (self._dy ** 2);

        # Partial derivative
        fxy = (self.grid[2:, 2:] - self.grid[2:, 1:-1] - self.grid[1:-1, 2:] + 2 * self.grid[1:-1, 1:-1] -
               self.grid[:-2,1:-1] - self.grid[1:-1,:-2] + self.grid[:-2,:-2])
        fxy = fxy / (4 * self._dx * self._dy)

        # Contour curvature
        ContCurv[1:-1, 1:-1] = (fxx * fy ** 2 - 2 * fxy * fx * fy + fyy * fx ** 2) / (
                    (fx ** 2 + fy ** 2) * np.sqrt((fx ** 2 + fy ** 2) + 1))

        if not(returnAsArray):
            ContCurv = self.duplicateGridWithNewArray(ContCurv, newSuffix=FILESUFFIXDICT['contour_curvature'])

        return ContCurv

    def calcHillshade(self, azimuth = 315, altitude = 45, returnAsArray = False):
        '''
        Calculates and returns a hillshade for this dem
        :param azimuth:
        :param angle_altitude:
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return:
        '''

        #Get slope and slope facing direction
        Sx, Sy = self.calcSlopes(returnAsArray = True)
        slp = np.pi / 2.0 - np.arctan(np.sqrt(Sx**2 + Sy**2))
        aspect = np.arctan2(Sy,Sx)

        #Transform light direction information
        azimuth = 360 - azimuth
        azimuth *= np.pi / 180.0
        altitude *= np.pi / 180.0

        #Calculate shading intensity on a 0-1 scale
        shaded = np.sin(altitude) * np.sin(slp) + np.cos(altitude) * np.cos(slp) * np.cos((azimuth - np.pi/2) - aspect)

        #Transform to 0 - 255
        shaded*=255

        #Reset nodata values
        shaded[np.isnan(self.grid)] = np.nan

        #Convert to dem grid if requested
        if not(returnAsArray):
            shaded = self.duplicateGridWithNewArray(shaded, newSuffix=FILESUFFIXDICT['hillshade'])

        return shaded

    def calcAzimuth(self, N:int = None, returnAsArray: bool = False):
        '''
        Calculates the azimuth of the slope in the standard angular reference of geologists; 0/360 is North, 90 is East,
        180 is South, 270 is west.
        :return:
        '''

        if N is None:
            Sx, Sy = self.calcSlopes(returnAsArray=True)
        elif isinstance(N,int):
            Sx, Sy = self.calcFiniteSlopesOverWindow(N = N, returnAsArray=True)
        else:
            raise Exception('Whoops, N must be either None or an integer.')

        #Calculate theta
        theta = np.arctan2(-Sy,-Sx) #Get the downhill direction

        #Convert from radians to degrees
        asp = np.rad2deg(theta)

        '''
        Radians is laid out:
        
                 90
        180/-180     0
                -90
                
        Want to get to:
        
                 0
            270     90
                180
        
        '''

        #Subtract 90 from everything to rotate north to the top
        asp-=90.0

        #Not most values are negative, except what was between 90 and 180.
        positiveQuadrant = asp >= 0

        #Restart this positive quadrant to count up (clockwise) from 270
        asp[positiveQuadrant] = 360 - asp[positiveQuadrant]

        #Everything not it the positive quadrant should just have the wront sign now
        asp[~positiveQuadrant]*=-1

        # # Negative radians
        # isNegative = theta < 0
        # asp[isNegative] = 90.0 + (180.0 / np.pi) * -theta[isNegative]
        #
        # # Positive radians, less than pi/2
        # isFirstQuad = (theta >= 0) & (theta < np.pi / 2)
        # asp[isFirstQuad] = 90 - (180.0 / np.pi) * theta[isFirstQuad]
        #
        # # Positive radians, greater than pi/2
        # isSecondQuad = (theta >= np.pi / 2)
        # asp[isSecondQuad] = 270.0 + (180.0 / np.pi) * (np.pi - theta[isSecondQuad])

        if not(returnAsArray):
            asp = self.duplicateGridWithNewArray(asp, newSuffix=FILESUFFIXDICT['aspect'])

        return asp

    def calcFiniteSlopesOverWindow(self, N = 2, returnAsArray = False):
        '''
        sx,sy = calcFiniteSlopesOverWindow(N = 2)
        calculates finite differences in X and Y direction using a finite difference kernel that extends N cells
        from the center. The width of the kernel is then 2N + 1 by 2N + 1. Applies a boundary condition such that the
        size and location of the grids in is the same as that out. However, the larger N is, the more NoData will be
        around the edges .

        :param N: Integer, Half width of window for centered difference kernel
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return: Sx, Sy numpy arrays the same size as this grid
        '''


        # Compute finite differences
        Sx = (self.grid[N:-N, (2 * N):] - self.grid[N:-N, :-(2 * N)]) / ((2 * N) * self._dx)

        #Note - direction of slope substraction is flipped because grid is reversed (high indices are low latitudes)
        Sy = (self.grid[:-(2 * N), N:-N] - self.grid[(2 * N):, N:-N]) / ((2 * N) * self._dy)

        # Create two new arrays of the original DEMs size
        SxPadded = np.empty(self.grid.shape)
        SxPadded[:] = np.NAN
        SyPadded = np.empty(self.grid.shape)
        SyPadded[:] = np.NAN

        #Populate padded arrays with known values
        SyPadded[N:-N, N:-N] = Sy
        SxPadded[N:-N, N:-N] = Sx

        if not(returnAsArray):
            SxPadded = self.duplicateGridWithNewArray(SxPadded, newSuffix=FILESUFFIXDICT['windowed_slope_x']+str(int(N)))
            SyPadded = self.duplicateGridWithNewArray(SyPadded, newSuffix=FILESUFFIXDICT['windowed_slope_y']+str(int(N)))

        return SxPadded, SyPadded

    def calcFiniteSlopeMagOverWindow(self, N = 2, returnAsArray = False):
        '''
        S = calcFiniteSlopeMagOverWindow(N = 2)
        calculates the magnitude of finite differences in X and Y direction using a finite difference kernel that extends
        N cells from the center. The width of the kernel is then 2N + 1 by 2N + 1. Applies a boundary condition such
        that the size and location of the grids in is the same as that out. However, the larger N is, the more NoData
        will be around the edges .

        :param N: Integer, Half width of window for centered difference kernel
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return: Smag,  numpy array the same size as this grid. Smag = (Sx^2 + Sy^2)^(1/2)
        '''

        Sx, Sy = self.calcFiniteSlopesOverWindow(N=N,returnAsArray=True)

        Smag = np.sqrt(Sx*Sx + Sy*Sy)

        if not(returnAsArray):
            Smag = self.duplicateGridWithNewArray(Smag, newSuffix=FILESUFFIXDICT['windowed_slope_mag']+str(int(N)))

        return Smag

    def calcFiniteLaplacianOverWindow(self,N = 2, returnAsArray = False):
        '''
        C = calcFiniteLaplacianOverWindow(N = 2)

        calculates second derivitive approximation using finite differences in X and Y direction using a finite
        difference kernel that extends N cells from the center. The width of the kernel is then 2N + 1 by 2N + 1.
        Applies a boundary condition such that the size and location of the grids in is the same as that out.
        However, the larger N is, the more NoData will be around the edges .

        :param N: Integer, Half width of window for centered difference kernel
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return: Crv,
        '''

        # Assign boundary conditions
        C = np.zeros_like(self.grid) * np.nan

        # Compute finite differences
        Cx = (self.grid[N:-N, (2 * N):] - 2 * self.grid[N:-N, N:-N] + self.grid[N:-N,:-(2 * N)]) / (2 * self._dx * N) ** 2
        Cy = (self.grid[(2 * N):, N:-N] - 2 * self.grid[N:-N, N:-N] + self.grid[:-(2 * N),N:-N]) / (2 * self._dy * N) ** 2

        # Populate padded array
        C[N:-N, N:-N] = Cx + Cy

        if not(returnAsArray):
            C = self.duplicateGridWithNewArray(C, newSuffix=FILESUFFIXDICT['windowed_curvature']+str(int(N)))

        return C

    def calculateGaussianMean(self,pixel_width = 2, returnAsArray = False):
        '''

        :param pixel_width:
        :type pixel_width:
        :param returnAsArray:
        :type returnAsArray:
        :return:
        :rtype:
        '''
        smoothGrid = ndi.gaussian_filter(self.grid,(pixel_width,pixel_width))

        if not(returnAsArray):
            smoothGrid = self.duplicateGridWithNewArray(smoothGrid,
                                                        newSuffix=FILESUFFIXDICT['gaussian_mean']+str(int(pixel_width)))

        return smoothGrid

    def calculateWindowedSTD(self,pixel_width = 10,doUseCircularWindow:bool = False, returnAsArray = False):
        '''
        Calculates the standard deviation of grid values in a moving window. The window is as wide as is specified by
        pixel_width (e.g., 10 x 10 pixels). Optionally, a circular window can be used, in which case the pixel_width
        specifies the diameter of the ciruclar window.

        :param pixel_width: The width of the moving window (either
        :param doUseCircularWindow:
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return: stdGrid: a duplicated instance of this demGrid, with each cell's value equal to the standard deviation
        of the original grid within the specified window
        '''

        if doUseCircularWindow:
            halfWidth = pixel_width/2.0
            coords = np.arange(pixel_width)-halfWidth
            fX,fY = np.meshgrid(coords,coords)
            dist = np.sqrt(fX**2 + fY**2)
            footprint = dist<=halfWidth
        else:
            footprint = np.ones((pixel_width,pixel_width))

        gridOut = ndi.generic_filter(self.grid,np.std,footprint = footprint,mode = 'constant',cval = np.nan)

        if not returnAsArray:
            gridOut = self.duplicateGridWithNewArray(gridOut,
                                                     newSuffix=FILESUFFIXDICT['windowed_std']+str(int(pixel_width)))

        return gridOut

    def calculateWindowedMedian(self,pixel_width = 10,doUseCircularWindow:bool = False, returnAsArray = False):
        '''
        Calculates the median of grid values in a moving window. The window is as wide as is specified by
        pixel_width (e.g., 10 x 10 pixels). Optionally, a circular window can be used, in which case the pixel_width
        specifies the diameter of the ciruclar window.

        :param pixel_width: The width of the moving window (either
        :param doUseCircularWindow:
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return: medGrid: a duplicated instance of this demGrid, with each cell's value equal to the median
        of the original grid within the specified window
        '''

        if doUseCircularWindow:
            halfWidth = pixel_width/2.0
            coords = np.arange(pixel_width)-halfWidth
            fX,fY = np.meshgrid(coords,coords)
            dist = np.sqrt(fX**2 + fY**2)
            footprint = dist<=halfWidth
        else:
            footprint = np.ones((pixel_width,pixel_width))

        gridOut = ndi.generic_filter(self.grid,np.median,footprint = footprint,mode = 'constant',cval = np.nan)

        if not returnAsArray:
            gridOut = self.duplicateGridWithNewArray(gridOut,
                                                     newSuffix=FILESUFFIXDICT['windowed_med']+str(int(pixel_width)))

        return gridOut

    def calcTPI(self,innerRadius:float, outerRadius:float, returnAsArray:bool = False):
        '''
        Calculates the topographic position index (TPI) for this grid. TPI measures the difference between the value of
        each DEM pixel and the mean value calculated within an annulus centered on that pixel. The annulus is described
        by two parameters, and inner radius (innerRadius) and an outer radius (outerRadius) measured in the native
        units of this DEM.

        :param innerRadius: The inner radius of the annulus used for the TPI calculation (in the native units of this
        DEM, e.g., meters)
        :param outerRadius: The inner radius of the annulus used for the TPI calculation (in the native units of this
        DEM, e.g., meters)
        :param returnAsArray: Boolean (default: False), if True returns slopes as numpy arrays instead of demGrid instance
        :return: The TPI grid calculated for this DEM, either as a demGrid instance or a numpy array depending on the
        value of returnAsArray
        '''

        #Find the outermost pixel distance for the outer radius
        pxlWidthOuter_x = np.ceil(outerRadius/self._dx)
        pxlWidthOuter_y = np.ceil(outerRadius/self._dy)

        #Get the grid of x and y coordinates to each cell in the search kernel
        X,Y = np.meshgrid(np.arange(-pxlWidthOuter_x,pxlWidthOuter_x+1)*self._dx,
                          np.arange(-pxlWidthOuter_y,pxlWidthOuter_y+1)*self._dy)

        #Calculate the distance to each cell in the kernel
        kernDist = np.sqrt(X*X + Y*Y)

        #Define the masked footprint
        footprint = 1.0*((kernDist > innerRadius) & (kernDist <= outerRadius))

        ###Option one, use convolution for the mean
        footprint_conv = footprint / np.sum(footprint.flatten())  # Normalize the footprint to be a mean
        # convolve the two
        gridOut = self.grid - ndi.convolve(self.grid, footprint_conv, mode='constant', cval=np.nan)

        ###An alternative option - use generic filter for the mean, is significantly slower (100x for tested sizes)
        # gridOut = self.grid - ndi.generic_filter(self.grid,np.mean,footprint=footprint,mode = 'constant',cval = np.nan)

        if not returnAsArray:
            #FileSuffix
            newSuffix = FILESUFFIXDICT['topographic_position_index'] + '{:.0f}_{:.0f}'.format(innerRadius,outerRadius)
            gridOut = self.duplicateGridWithNewArray(gridOut,newSuffix=newSuffix)

        return gridOut

    def extractGridSubset(self,minX : float,maxX : float,minY : float,maxY : float, returnAsArray = False):
        '''
        Extract a grid subset within the specified bounding coordinates. Extracts based on the nearest coordinates
        within the specified bounds (e.g., does not interpolate the extracted grid, just subsets it).

        :param minX: the minimum bounding x coordinate (e.g., left side of extracted rectangle)
        :param maxX: the maximum bounding x coordinate (e.g., right side of extracted rectangle)
        :param minY: the minimum bounding y coordinate (e.g., bottom of extracted rectangle)
        :param maxY: the maximum bounding y coordinate (e.g., top of extracted rectangle)
        :return:
        '''

        #First step, check that all coordinates are in bounds

        withinXBounds = (minX >= self._xllcenter) & (maxX <= (self._dx*(self._ncols-1) + self._xllcenter))
        withinYBounds = (minY >= self._yllcenter) & (maxY <= (self._dy*(self._nrows-1)) + self._yllcenter)
        if  withinXBounds & withinYBounds:
            #Get the grid subset
            rowLL, colLL = self.getRowColFromXY([minX,minY])
            rowUR, colUR = self.getRowColFromXY([maxX,maxY])

            # Keep in mind, gdal loads in grids so that top is low row index, bottom is high row index
            gridSubset = self.grid[rowUR:rowLL,colLL:colUR]

            ##If the user requested to just return the grid subset as an array, no need to assign its georeferencing
            if not(returnAsArray):
                newGeotransofrm = [a for a in self._geotransform] #Copy the values for the current geotransform
                newGeotransofrm[0] = minX - self._dx / 2.0 #Upper left x coordinate
                newGeotransofrm[3] = minY + (self._dy * (self._nrows - 0.5)) #Upper left y coordinate

                gridSubset = demGrid(gridSubset,geotransform=newGeotransofrm,projection=self._projection)

        else:
            raise Exception('Error, one or more of the specified bounding coordinates extends beyond this grids limits')
            gridSubset = None

        return gridSubset

    def userSelected_extractGridSubset(self,returnAsArray = False,**plotKwargs):
        '''
        Draws a plot of the grid and allows the user to select a rectangular box within that grid.  Returns
        the subset of the grid within that box either as an array or as a demGrid instance.
        :param returnAsArray: boolean (default: false), if true, returns the grid subset as a numpy array
        :param plotKwargs: Any options to pass to the pyplot.imshow operation used for region selection
        :return: gridSubset, the selected subset of the grid as either a numpy array of demGrid instance
        '''

        f,axs = plt.subplots(1,1)

        self.plotGrid(axs = axs,zorder = -1, **plotKwargs)
        axs.set_title('Select a rectangle, press ''Q'' when done.')

        ####Trying with rectangle selector
        xCoords = [None, None]
        yCoords = [None, None]

        def toggle_selector(event):
            print(' Key pressed.')
            if event.key in ['Q', 'q'] and toggle_selector.RS.active:
                print(' RectangleSelector deactivated.')
                toggle_selector.RS.set_active(False)
                plt.close(f)

            if event.key in ['A', 'a'] and not toggle_selector.RS.active:
                print(' RectangleSelector activated.')
                toggle_selector.RS.set_active(True)

        def callback_func(eclick, erelease):
            xCoords[:] =  eclick.xdata,erelease.xdata
            yCoords[:] =  eclick.ydata, erelease.ydata

        toggle_selector.RS = RectangleSelector(axs, callback_func, drawtype='line',minspanx = 5, minspany = 5,
                                         spancoords = 'pixels',interactive = True)

        plt.connect('button_press_event', toggle_selector)
        plt.show()
        while plt.fignum_exists(f.number):
            plt.waitforbuttonpress()

        gridSubset = self.extractGridSubset(np.min(xCoords), np.max(xCoords), np.min(yCoords), np.max(yCoords),
                                            returnAsArray=returnAsArray)
        return gridSubset

    def duplicateGridWithNewArray(self, newGrid : np.ndarray, newSuffix: str = None):
        '''
        Creates a copy of the specified 2d numpy array grid using the spatial data from the specified grid
        :param newGrid: a 2d numpy array.
        :param newSuffix: a string to append to the existing file name (if present)
        :return: newDemGridInstance: an instance of demGrid with the newGrid array data, and the projection information
        of this grid.
        '''

        if newGrid.shape == self.shape:
            newGridObj = demGrid(newGrid,geotransform=self._geotransform,projection=self._projection)

            # If this grid was loaded from a file, update file name information for the return grid with a new suffix
            if not (self._filePath is None) and isinstance(newSuffix, str):
                newGridObj._filePath = self._filePath
                newGridObj._gdalDriver = self._gdalDriver
                newGridObj._gdalDataType = self._gdalDataType
                newGridObj.updateFileNameWithSuffix(newSuffix)

        else:
            raise Exception('Whoops! Can not duplicate this grid with the specified array because it is the wrong shape')

        return newGridObj

    def loadDerivedGrid(self, derivativeSuffix: str):
        '''
        For a grid derived from this one, that has a suffix to the file name that is known, we can load it based on
        this grids file name.
        :param derivativeSuffix:
        :return:
        '''

        # If there is an existing filepath
        if not (self._filePath is None):
            # Split the file path at its extension
            preExt, Ext = os.path.splitext(self._filePath)

            # Insert the extension in between the file name and extension
            derivFilePath = preExt + derivativeSuffix + Ext

            # Load this other grid
            loadedGrid = demGrid([], rasterPath=derivFilePath)

        else:
            print('Whoops, no file path exists for this grid. Doing nothing.')
            loadedGrid = None

        return loadedGrid

    def movingWindowOperation(self, nrows:int, ncols:int, function:callable,
                              winWidth:float = None, winHeight:float = None,**extraArgs):
        '''
        :return:
        '''

        if not(winWidth is None):
            ncols = np.round(self._dx*self._ncols/winWidth).astype(np.int)

        if not(winHeight) is None:
            nrows = np.round(self._dy*self._nrows/winHeight).astype(np.int)


        xWinBounds = np.linspace(self._xllcenter, (self._dx*(self._ncols-1) + self._xllcenter), ncols+1)
        yWinBounds = np.linspace(self._yllcenter, (self._dy*(self._nrows-1) + self._yllcenter), nrows+1)

        #Create dictionary of outputs
        outputDict = {}

        for i in range(ncols):
            minX = xWinBounds[i]
            maxX = xWinBounds[i+1]
            for j in range(nrows):
                minY = yWinBounds[j]
                maxY = yWinBounds[j + 1]
                theseCoords = (minX,maxX,minY,maxY)
                outputDict[theseCoords] =  function(self,theseCoords,**extraArgs)

        return outputDict
